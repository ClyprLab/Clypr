import {
  __commonJS,
  init_buffer,
  init_process
} from "./chunk-IOWPNI5S.js";

// ../../../../../.yarn/berry/cache/simple-cbor-npm-0.4.1-9c9f94e4ce-10c0.zip/node_modules/simple-cbor/src/value.js
var require_value = __commonJS({
  "../../../../../.yarn/berry/cache/simple-cbor-npm-0.4.1-9c9f94e4ce-10c0.zip/node_modules/simple-cbor/src/value.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    var MAX_U64_NUMBER = 9007199254740992;
    function _concat(a, ...args) {
      const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));
      newBuffer.set(new Uint8Array(a), 0);
      let i = a.byteLength;
      for (const b of args) {
        newBuffer.set(new Uint8Array(b), i);
        i += b.byteLength;
      }
      return newBuffer.buffer;
    }
    function _serializeValue(major, minor, value) {
      value = value.replace(/[^0-9a-fA-F]/g, "");
      const length = 2 ** (minor - 24);
      value = value.slice(-length * 2).padStart(length * 2, "0");
      const bytes2 = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));
      return new Uint8Array(bytes2).buffer;
    }
    function _serializeNumber(major, value) {
      if (value < 24) {
        return new Uint8Array([(major << 5) + value]).buffer;
      } else {
        const minor = value <= 255 ? 24 : value <= 65535 ? 25 : value <= 4294967295 ? 26 : 27;
        return _serializeValue(major, minor, value.toString(16));
      }
    }
    function _serializeString(str) {
      const utf8 = [];
      for (let i = 0; i < str.length; i++) {
        let charcode = str.charCodeAt(i);
        if (charcode < 128) {
          utf8.push(charcode);
        } else if (charcode < 2048) {
          utf8.push(192 | charcode >> 6, 128 | charcode & 63);
        } else if (charcode < 55296 || charcode >= 57344) {
          utf8.push(224 | charcode >> 12, 128 | charcode >> 6 & 63, 128 | charcode & 63);
        } else {
          i++;
          charcode = (charcode & 1023) << 10 | str.charCodeAt(i) & 1023;
          utf8.push(240 | charcode >> 18, 128 | charcode >> 12 & 63, 128 | charcode >> 6 & 63, 128 | charcode & 63);
        }
      }
      return _concat(new Uint8Array(_serializeNumber(3, str.length)), new Uint8Array(utf8));
    }
    function tagged(tag, value) {
      if (tag == 14277111) {
        return _concat(new Uint8Array([217, 217, 247]), value);
      }
      if (tag < 24) {
        return _concat(new Uint8Array([(6 << 5) + tag]), value);
      } else {
        const minor = tag <= 255 ? 24 : tag <= 65535 ? 25 : tag <= 4294967295 ? 26 : 27;
        const length = 2 ** (minor - 24);
        const value2 = tag.toString(16).slice(-length * 2).padStart(length * 2, "0");
        const bytes2 = [(6 << 5) + minor].concat(value2.match(/../g).map((byte) => parseInt(byte, 16)));
        return new Uint8Array(bytes2).buffer;
      }
    }
    exports.tagged = tagged;
    function raw(bytes2) {
      return new Uint8Array(bytes2).buffer;
    }
    exports.raw = raw;
    function uSmall(n) {
      if (isNaN(n)) {
        throw new RangeError("Invalid number.");
      }
      n = Math.min(Math.max(0, n), 23);
      const bytes2 = [(0 << 5) + n];
      return new Uint8Array(bytes2).buffer;
    }
    exports.uSmall = uSmall;
    function u8(u82, radix) {
      u82 = parseInt("" + u82, radix);
      if (isNaN(u82)) {
        throw new RangeError("Invalid number.");
      }
      u82 = Math.min(Math.max(0, u82), 255);
      u82 = u82.toString(16);
      return _serializeValue(0, 24, u82);
    }
    exports.u8 = u8;
    function u16(u162, radix) {
      u162 = parseInt("" + u162, radix);
      if (isNaN(u162)) {
        throw new RangeError("Invalid number.");
      }
      u162 = Math.min(Math.max(0, u162), 65535);
      u162 = u162.toString(16);
      return _serializeValue(0, 25, u162);
    }
    exports.u16 = u16;
    function u32(u322, radix) {
      u322 = parseInt("" + u322, radix);
      if (isNaN(u322)) {
        throw new RangeError("Invalid number.");
      }
      u322 = Math.min(Math.max(0, u322), 4294967295);
      u322 = u322.toString(16);
      return _serializeValue(0, 26, u322);
    }
    exports.u32 = u32;
    function u64(u642, radix) {
      if (typeof u642 == "string" && radix == 16) {
        if (u642.match(/[^0-9a-fA-F]/)) {
          throw new RangeError("Invalid number.");
        }
        return _serializeValue(0, 27, u642);
      }
      u642 = parseInt("" + u642, radix);
      if (isNaN(u642)) {
        throw new RangeError("Invalid number.");
      }
      u642 = Math.min(Math.max(0, u642), MAX_U64_NUMBER);
      u642 = u642.toString(16);
      return _serializeValue(0, 27, u642);
    }
    exports.u64 = u64;
    function iSmall(n) {
      if (isNaN(n)) {
        throw new RangeError("Invalid number.");
      }
      if (n === 0) {
        return uSmall(0);
      }
      n = Math.min(Math.max(0, -n), 24) - 1;
      const bytes2 = [(1 << 5) + n];
      return new Uint8Array(bytes2).buffer;
    }
    exports.iSmall = iSmall;
    function i8(i82, radix) {
      i82 = parseInt("" + i82, radix);
      if (isNaN(i82)) {
        throw new RangeError("Invalid number.");
      }
      i82 = Math.min(Math.max(0, -i82 - 1), 255);
      i82 = i82.toString(16);
      return _serializeValue(1, 24, i82);
    }
    exports.i8 = i8;
    function i16(i162, radix) {
      i162 = parseInt("" + i162, radix);
      if (isNaN(i162)) {
        throw new RangeError("Invalid number.");
      }
      i162 = Math.min(Math.max(0, -i162 - 1), 65535);
      i162 = i162.toString(16);
      return _serializeValue(1, 25, i162);
    }
    exports.i16 = i16;
    function i32(i322, radix) {
      i322 = parseInt("" + i322, radix);
      if (isNaN(i322)) {
        throw new RangeError("Invalid number.");
      }
      i322 = Math.min(Math.max(0, -i322 - 1), 4294967295);
      i322 = i322.toString(16);
      return _serializeValue(1, 26, i322);
    }
    exports.i32 = i32;
    function i64(i642, radix) {
      if (typeof i642 == "string" && radix == 16) {
        if (i642.startsWith("-")) {
          i642 = i642.slice(1);
        } else {
          i642 = "0";
        }
        if (i642.match(/[^0-9a-fA-F]/) || i642.length > 16) {
          throw new RangeError("Invalid number.");
        }
        let done = false;
        let newI64 = i642.split("").reduceRight((acc, x) => {
          if (done) {
            return x + acc;
          }
          let n = parseInt(x, 16) - 1;
          if (n >= 0) {
            done = true;
            return n.toString(16) + acc;
          } else {
            return "f" + acc;
          }
        }, "");
        if (!done) {
          return u64(0);
        }
        return _serializeValue(1, 27, newI64);
      }
      i642 = parseInt("" + i642, radix);
      if (isNaN(i642)) {
        throw new RangeError("Invalid number.");
      }
      i642 = Math.min(Math.max(0, -i642 - 1), 9007199254740992);
      i642 = i642.toString(16);
      return _serializeValue(1, 27, i642);
    }
    exports.i64 = i64;
    function number(n) {
      if (n >= 0) {
        if (n < 24) {
          return uSmall(n);
        } else if (n <= 255) {
          return u8(n);
        } else if (n <= 65535) {
          return u16(n);
        } else if (n <= 4294967295) {
          return u32(n);
        } else {
          return u64(n);
        }
      } else {
        if (n >= -24) {
          return iSmall(n);
        } else if (n >= -255) {
          return i8(n);
        } else if (n >= -65535) {
          return i16(n);
        } else if (n >= -4294967295) {
          return i32(n);
        } else {
          return i64(n);
        }
      }
    }
    exports.number = number;
    function bytes(bytes2) {
      return _concat(_serializeNumber(2, bytes2.byteLength), bytes2);
    }
    exports.bytes = bytes;
    function string(str) {
      return _serializeString(str);
    }
    exports.string = string;
    function array(items) {
      return _concat(_serializeNumber(4, items.length), ...items);
    }
    exports.array = array;
    function map(items, stable = false) {
      if (!(items instanceof Map)) {
        items = new Map(Object.entries(items));
      }
      let entries = Array.from(items.entries());
      if (stable) {
        entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));
      }
      return _concat(_serializeNumber(5, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));
    }
    exports.map = map;
    function singleFloat(f) {
      const single = new Float32Array([f]);
      return _concat(new Uint8Array([(7 << 5) + 26]), new Uint8Array(single.buffer));
    }
    exports.singleFloat = singleFloat;
    function doubleFloat(f) {
      const single = new Float64Array([f]);
      return _concat(new Uint8Array([(7 << 5) + 27]), new Uint8Array(single.buffer));
    }
    exports.doubleFloat = doubleFloat;
    function bool(v) {
      return v ? true_() : false_();
    }
    exports.bool = bool;
    function true_() {
      return raw(new Uint8Array([(7 << 5) + 21]));
    }
    exports.true_ = true_;
    function false_() {
      return raw(new Uint8Array([(7 << 5) + 20]));
    }
    exports.false_ = false_;
    function null_() {
      return raw(new Uint8Array([(7 << 5) + 22]));
    }
    exports.null_ = null_;
    function undefined_() {
      return raw(new Uint8Array([(7 << 5) + 23]));
    }
    exports.undefined_ = undefined_;
  }
});

// ../../../../../.yarn/berry/cache/simple-cbor-npm-0.4.1-9c9f94e4ce-10c0.zip/node_modules/simple-cbor/src/serializer.js
var require_serializer = __commonJS({
  "../../../../../.yarn/berry/cache/simple-cbor-npm-0.4.1-9c9f94e4ce-10c0.zip/node_modules/simple-cbor/src/serializer.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var cbor = __importStar(require_value());
    var BufferClasses = [
      ArrayBuffer,
      Uint8Array,
      Uint16Array,
      Uint32Array,
      Int8Array,
      Int16Array,
      Int32Array,
      Float32Array,
      Float64Array
    ];
    var JsonDefaultCborEncoder = class {
      // @param _serializer The CBOR Serializer to use.
      // @param _stable Whether or not keys from objects should be sorted (stable). This is
      //     particularly useful when testing encodings between JSON objects.
      constructor(_serializer, _stable = false) {
        this._serializer = _serializer;
        this._stable = _stable;
        this.name = "jsonDefault";
        this.priority = -100;
      }
      match(value) {
        return ["undefined", "boolean", "number", "string", "object"].indexOf(typeof value) != -1;
      }
      encode(value) {
        switch (typeof value) {
          case "undefined":
            return cbor.undefined_();
          case "boolean":
            return cbor.bool(value);
          case "number":
            if (Math.floor(value) === value) {
              return cbor.number(value);
            } else {
              return cbor.doubleFloat(value);
            }
          case "string":
            return cbor.string(value);
          case "object":
            if (value === null) {
              return cbor.null_();
            } else if (Array.isArray(value)) {
              return cbor.array(value.map((x) => this._serializer.serializeValue(x)));
            } else if (BufferClasses.find((x) => value instanceof x)) {
              return cbor.bytes(value.buffer);
            } else if (Object.getOwnPropertyNames(value).indexOf("toJSON") !== -1) {
              return this.encode(value.toJSON());
            } else if (value instanceof Map) {
              const m = /* @__PURE__ */ new Map();
              for (const [key, item] of value.entries()) {
                m.set(key, this._serializer.serializeValue(item));
              }
              return cbor.map(m, this._stable);
            } else {
              const m = /* @__PURE__ */ new Map();
              for (const [key, item] of Object.entries(value)) {
                m.set(key, this._serializer.serializeValue(item));
              }
              return cbor.map(m, this._stable);
            }
          default:
            throw new Error("Invalid value.");
        }
      }
    };
    exports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;
    var ToCborEncoder = class {
      constructor() {
        this.name = "cborEncoder";
        this.priority = -90;
      }
      match(value) {
        return typeof value == "object" && typeof value["toCBOR"] == "function";
      }
      encode(value) {
        return value.toCBOR();
      }
    };
    exports.ToCborEncoder = ToCborEncoder;
    var CborSerializer = class {
      constructor() {
        this._encoders = /* @__PURE__ */ new Set();
      }
      static withDefaultEncoders(stable = false) {
        const s = new this();
        s.addEncoder(new JsonDefaultCborEncoder(s, stable));
        s.addEncoder(new ToCborEncoder());
        return s;
      }
      removeEncoder(name) {
        for (const encoder of this._encoders.values()) {
          if (encoder.name == name) {
            this._encoders.delete(encoder);
          }
        }
      }
      addEncoder(encoder) {
        this._encoders.add(encoder);
      }
      getEncoderFor(value) {
        let chosenEncoder = null;
        for (const encoder of this._encoders) {
          if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {
            if (encoder.match(value)) {
              chosenEncoder = encoder;
            }
          }
        }
        if (chosenEncoder === null) {
          throw new Error("Could not find an encoder for value.");
        }
        return chosenEncoder;
      }
      serializeValue(value) {
        return this.getEncoderFor(value).encode(value);
      }
      serialize(value) {
        return this.serializeValue(value);
      }
    };
    exports.CborSerializer = CborSerializer;
    var SelfDescribeCborSerializer = class extends CborSerializer {
      serialize(value) {
        return cbor.raw(new Uint8Array([
          // Self describe CBOR.
          ...new Uint8Array([217, 217, 247]),
          ...new Uint8Array(super.serializeValue(value))
        ]));
      }
    };
    exports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;
  }
});

// ../../../../../.yarn/berry/cache/simple-cbor-npm-0.4.1-9c9f94e4ce-10c0.zip/node_modules/simple-cbor/src/index.js
var require_src = __commonJS({
  "../../../../../.yarn/berry/cache/simple-cbor-npm-0.4.1-9c9f94e4ce-10c0.zip/node_modules/simple-cbor/src/index.js"(exports) {
    init_process();
    init_buffer();
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k))
            result[k] = mod[k];
      }
      result["default"] = mod;
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(require_serializer());
    var value = __importStar(require_value());
    exports.value = value;
  }
});

export {
  require_src
};
//# sourceMappingURL=chunk-EQCP24P7.js.map
