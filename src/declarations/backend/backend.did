type WebhookConfig = 
 record {
   authType:
    variant {
      basic: record {
               password: text;
               username: text;
             };
      bearer: text;
      none;
    };
   headers: vec record {
                  text;
                  text;
                };
   method: text;
   retryCount: nat8;
   url: text;
 };
type ValidationConfig = 
 record {
   contentLimits: ContentLimits;
   rateLimit: RateLimit;
 };
type SMTPSettings = 
 record {
   host: text;
   password: text;
   port: nat16;
   useTLS: bool;
   username: text;
 };
type SMSConfig = 
 record {
   apiKey: text;
   fromNumber: text;
   provider: text;
   webhookUrl: opt text;
 };
type RuleId = nat;
type Rule = 
 record {
   actions: vec Action;
   conditions: vec Condition;
   createdAt: int;
   dappPrincipal: opt principal;
   description: opt text;
   id: RuleId;
   isActive: bool;
   name: text;
   priority: nat8;
   updatedAt: int;
 };
type RetryConfig = 
 record {
   backoffMs: nat32;
   maxAttempts: nat8;
   timeoutMs: nat32;
 };
type Result_9 = 
 variant {
   err: Error;
   ok: text;
 };
type Result_8 = 
 variant {
   err: Error;
   ok: Rule;
 };
type Result_7 = 
 variant {
   err: Error;
   ok:
    record {
      blockedCount: nat;
      channelsCount: nat;
      deliveredCount: nat;
      messagesCount: nat;
      rulesCount: nat;
    };
 };
type Result_6 = 
 variant {
   err: Error;
   ok: vec principal;
 };
type Result_5 = 
 variant {
   err: Error;
   ok: vec DispatchJob;
 };
type Result_4 = 
 variant {
   err: Error;
   ok: MessageReceipt;
 };
type Result_3 = 
 variant {
   err: Error;
   ok: nat;
 };
type Result_2 = 
 variant {
   err: Error;
   ok: principal;
 };
type Result_16 = 
 variant {
   err: Error;
   ok: ChannelId;
 };
type Result_15 = 
 variant {
   err: Error;
   ok: RuleId;
 };
type Result_14 = 
 variant {
   err: Error;
   ok: vec Channel;
 };
type Result_13 = 
 variant {
   err: Error;
   ok: vec Message;
 };
type Result_12 = 
 variant {
   err: Error;
   ok: vec Rule;
 };
type Result_11 = 
 variant {
   err: Error;
   ok: Channel;
 };
type Result_10 = 
 variant {
   err: Error;
   ok: Message;
 };
type Result_1 = 
 variant {
   err: Error;
   ok: ChannelTestResult;
 };
type Result = 
 variant {
   err: Error;
   ok;
 };
type RateLimit = 
 record {
   maxRequests: nat32;
   perChannel: bool;
   windowMs: nat32;
 };
type PushConfig = 
 record {
   apiKey: text;
   appId: text;
   platform: variant {
               apn;
               fcm;
               webpush;
             };
   provider: text;
 };
type MessageStatus = 
 variant {
   blocked;
   delivered;
   failed;
   processing;
   queued;
   received;
 };
type MessageReceipt = 
 record {
   messageId: MessageId;
   received: bool;
   timestamp: int;
 };
type MessageId = text;
type MessageContent = 
 record {
   body: text;
   contentType: text;
   metadata: vec record {
                   text;
                   text;
                 };
   priority: nat8;
   title: text;
 };
type Message = 
 record {
   content: MessageContent;
   isProcessed: bool;
   messageId: MessageId;
   messageType: text;
   recipientId: principal;
   senderId: principal;
   status: MessageStatus;
   timestamp: int;
 };
type JobSchedule = 
 variant {
   delayed: int;
   immediate;
   recurring: record {
                interval: nat32;
                nextRun: int;
              };
 };
type Error = 
 variant {
   AlreadyExists: opt text;
   ChannelError: ChannelTestResult;
   InternalError;
   InvalidConfig: vec text;
   InvalidInput: opt text;
   NotAuthorized;
   NotFound;
   Other: text;
   RateLimitExceeded;
 };
type EmailConfig = 
 record {
   apiKey: opt text;
   fromAddress: text;
   provider: text;
   replyTo: opt text;
   smtp: opt SMTPSettings;
 };
type DispatchStatus = 
 variant {
   delivered;
   failed;
   pending;
 };
type DispatchMetadata = 
 record {
   attempts: vec AttemptRecord;
   deliveryReport: opt DeliveryReport;
   lastError: opt text;
 };
type DispatchJob = 
 record {
   attempts: nat;
   channelConfig: ChannelConfig;
   channelId: ChannelId;
   channelName: text;
   channelType: ChannelType;
   content: MessageContent;
   createdAt: int;
   expiresAt: int;
   id: nat;
   intents: vec record {
                  text;
                  text;
                };
   messageId: MessageId;
   messageType: text;
   metadata: opt DispatchMetadata;
   recipientId: principal;
   retryConfig: RetryConfig;
   status: DispatchStatus;
 };
type DeliveryReport = 
 record {
   channelId: ChannelId;
   metadata: vec record {
                   text;
                   text;
                 };
   providerId: text;
   status: text;
   timestamp: int;
 };
type ContentLimits = 
 record {
   allowedContentTypes: vec text;
   maxBodyLength: nat32;
   maxMetadataCount: nat32;
   maxTitleLength: nat32;
 };
type ConditionOperator = 
 variant {
   contains;
   equals;
   exists;
   greaterThan;
   lessThan;
   notContains;
   notEquals;
   notExists;
 };
type Condition = 
 record {
   field: text;
   operator: ConditionOperator;
   value: text;
 };
type ChannelType = 
 variant {
   custom: text;
   email;
   push;
   sms;
   webhook;
 };
type ChannelTestResult = 
 record {
   error: opt text;
   latencyMs: nat32;
   metadata: vec record {
                   text;
                   text;
                 };
   success: bool;
   timestamp: int;
 };
type ChannelId = nat;
type ChannelConfig = 
 variant {
   custom: vec record {
                 text;
                 text;
               };
   email: EmailConfig;
   push: PushConfig;
   sms: SMSConfig;
   webhook: WebhookConfig;
 };
type Channel = 
 record {
   channelType: ChannelType;
   config: ChannelConfig;
   createdAt: int;
   description: opt text;
   id: ChannelId;
   isActive: bool;
   name: text;
   retryConfig: RetryConfig;
   updatedAt: int;
   validationConfig: ValidationConfig;
 };
type AttemptRecord = 
 record {
   error: opt text;
   metadata: vec record {
                   text;
                   text;
                 };
   status: DispatchStatus;
   timestamp: int;
 };
type ActionType = 
 variant {
   allow;
   block;
   prioritize;
   route;
   transform;
 };
type Action = 
 record {
   actionType: ActionType;
   channelId: opt ChannelId;
   parameters: vec record {
                     text;
                     text;
                   };
 };
service : {
  acknowledgeJobDelivery: (jobId: nat, status: DispatchStatus) -> (Result);
  addAuthorizedSelf: () -> (Result);
  cleanupExpiredJobs: () -> (Result_3);
  createChannel: (name: text, description: opt text, channelType:
   ChannelType, config: ChannelConfig, retryConfig: opt RetryConfig,
   validationConfig: opt ValidationConfig) -> (Result_16);
  createRule: (name: text, description: opt text, dappPrincipal:
   opt principal, conditions: vec Condition, actions: vec Action, priority:
   nat8) -> (Result_15);
  deleteChannel: (channelId: ChannelId) -> (Result);
  deleteRule: (ruleId: RuleId) -> (Result);
  getAllChannels: () -> (Result_14) query;
  getAllMessages: () -> (Result_13) query;
  getAllRules: () -> (Result_12) query;
  getChannel: (channelId: ChannelId) -> (Result_11) query;
  getMessage: (messageId: MessageId) -> (Result_10) query;
  getMyUsername: () -> (Result_9) query;
  getRule: (ruleId: RuleId) -> (Result_8) query;
  getStats: () -> (Result_7) query;
  getSystemHealth: () ->
   (record {
      activeChannelsCount: nat;
      activeRulesCount: nat;
      pendingJobsCount: nat;
      totalJobsCompleted: nat;
      totalJobsFailed: nat;
      totalJobsScheduled: nat;
      totalMessagesProcessed: nat;
      uptime: int;
    }) query;
  init: () -> ();
  listAuthorized: () -> (Result_6) query;
  nextDispatchJobs: (limit: nat) -> (Result_5);
  notifyAlias: (recipientAlias: text, messageType: text, content:
   MessageContent) -> (Result_4);
  notifyPrincipal: (recipientId: principal, messageType: text, content:
   MessageContent) -> (Result_4);
  ping: () -> (text) query;
  /// Deprecated: prefer `notifyAlias` for clearer DX. Kept for backward-compat.
  processMessage: (recipientUsername: text, messageType: text, content:
   MessageContent) -> (Result_4);
  processScheduledJobs: () -> (Result_3);
  registerUsername: (username: text) -> (Result);
  removeAuthorizedSelf: () -> (Result);
  resolveUsername: (username: text) -> (Result_2) query;
  scheduleJob: (jobId: nat, schedule: JobSchedule) -> (Result);
  testChannel: (channelId: ChannelId) -> (Result_1);
  updateChannel: (channelId: ChannelId, updatedChannel: Channel) -> (Result);
  updateRule: (ruleId: RuleId, updatedRule: Rule) -> (Result);
}
